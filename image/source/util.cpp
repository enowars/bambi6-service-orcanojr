#include "util.h"

#include <cstdint>
#include <cstdlib>
#include <cstring>

InitFunctionReg *InitFunctionReg::s_pFirst = nullptr;

static int base64DecodeBatch(const char *start, uint8_t *out)
{
	constexpr static uint8_t k_lut[128] = {
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x3e, 0x80, 0x80, 0x80, 0x3f,
		0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
		0x3c, 0x3d, 0x80, 0x80, 0x80, 0x40, 0x80, 0x80,
		0x80, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
		0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
		0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
		0x17, 0x18, 0x19, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
		0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
		0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
		0x31, 0x32, 0x33, 0x80, 0x80, 0x80, 0x80, 0x80,
	};

	uint32_t batch = 0;
	int data_end = 4;
	for (int i = 0; i < 4; ++i)
	{
		char c = start[i];
		if (c >= OC_ARRAYSIZE(k_lut))
			return 0;

		uint8_t data = k_lut[(int)c];

		// Check for bad symbol
		if (data & 0x80)
			return 0;

		batch <<= 6;
		if (data & 0x40)
		{
			// Check for early end
			if (i < 2)
				return 0;
			
			// Start of padding?
			if (i < data_end)
				data_end = i;
		}
		else
		{
			// Check for data after padding
			if (data_end < 4)
				return 0;

			batch |= data;
		}
	}

	int bytes;
	if (data_end == 2)
		bytes = 1;
	else if (data_end == 3)
		bytes = 2;
	else if (data_end == 4)
		bytes = 3;
	else
		return 0;

	for (int i = 0; i < bytes; ++i)
	{
		int shift = ((2 - i) * 8);
		out[i] = (batch >> shift) & 0xff;
	}
	return bytes;
};

bool base64Decode(const char *text, void **out_buf, int *out_len)
{
	int in_len = strlen(text);
	if (in_len % 4)
		return false;

	int batch_count = in_len / 4;
	uint8_t *buffer = (uint8_t *)malloc(batch_count * 3);
	int buf_len = 0;
	for (int i = 0; i < batch_count; ++i)
	{
		int got = base64DecodeBatch(text + i * 4, buffer + buf_len);
		if (!got)
		{
			free(buffer);
			return false;
		}

		// Check for padding mid-text
		if (got < 3 && i != batch_count - 1)
		{
			free(buffer);
			return false;
		}

		buf_len += got;
	}

	*out_len = buf_len;
	*out_buf = buffer;
	return true;
}